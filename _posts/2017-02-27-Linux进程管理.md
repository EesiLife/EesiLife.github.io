---
layout: post
title:  Linux进程管理
date:   2017-02-27 10:25:00 +0800
tag: linux内核
---

##### 进程

&emsp;&emsp;&emsp;进程就是处于执行期的程序（目标码存放在某种存储介质上）。但进程并不仅仅局限于一段可执行程序代码。通常进程还要包括其他资源，像打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址控件及一个或多个执行线程(thread of execution)，当然还包括用来存放全局变量的数据段等。实际上，进程就是正在执行的程序代码的实时结果。内核需要有效而又透明地管理所有细节。

&emsp;&emsp;执行线程，简称线程，是在进程中活动的对象。每个线程都拥有一个盾立的程序计数器、进程栈、和一组进程寄存器。内核调度的对象时线程，而不是进程。在传统的Unix系统中，一个进程只包含一个线程，但现在的系统中，包含多个线程的多线程程序司空见惯。Linux系统的线程实现非常特别：它对线程和进程并不特别区分。对Linux而言，线程只不过时一种特殊的进程罢了。

&emsp;&emsp;进程提供两种虚拟机制：虚拟处理器和虚拟内存。

&emsp;&emsp;程序本身并不是进程，进程是处于执行期的程序以及相关的资源的总称。实际上，完全可能存在两个或多个不同的进程执行的时同一个程序。并且两个或两个以上并存的进程还可以共享许多诸如打开的文件、地址空间之类的资源。

&emsp;&emsp;Linux中，通常调用fork()系统的结果，该系统调用用通过复制一个现有进程来创建一个全新的进程。调用fork()的进程称为父进程，新产生的进程称为子进程。在该调用结束时，在返回点这个相同的位置上，父进程恢复执行，子进程开始执行。fork()系统调用从内核返回两次：一次回到父进程，另一次回到新产生的子进程。

&emsp;&emsp;通常，创建新的进程都是为了立即执行新的或不同的程序，而接着调用exec()这组函数就可以创建新的地址空间，并把新的程序载入其中。在现在Linux内核中，fork()实际上是由clone()系统实现的。

&emsp;&emsp;最终，程序通过exit()系统调用退出执行。这个函数会终结进程并将其占用的资源释放掉。父进程可以通过wait4()系统调用查询子进程是否中介，这其实使得进程呢拥有了等待特定进程执行完毕的能力。进程退出执行后被设置为僵死状态，
知道它的父进程调用wait()或waitpid()为止。

##### 进程描述符及任务结构

&emsp;&emsp;内核把进程的列表存放在任务队列中，它是双向循环链表。链表中的每一项都是类型为task_struck、称为进程描述符的结构。包含一个具体进程的所有信息。

&emsp;&emsp;例如：它打开的文件。进程的地址控件，挂起的信号。进程的状态，还有其他更多信息。

###### 分配进程描述符

&emsp;&emsp;通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色的目的。现用slab分配器动态生成task_struct，所以只需在栈底或栈顶创建一个新的结构struct thread_info。

&emsp;&emsp;在x86上，struct thread_info在文件<asm/thread_info.h>中定义如下：
```c++
struct thread_info{
	struct task_struct    *task;
    struct exec_domain    *exec_domain;
    _u32                  flags;
    _u32                  status;
    _u32                  cpu;
    int                   preempt_count;
    mm_setment_t          addr_limit;
    struct restart_block  restart_block;
    void                  *sysenter_return;
    int                   uaccess_err;
}
```
###### 进程描述符的存放

&emsp;&emsp;内核通过一个唯一的进程标识值或PID（max:32768）来标识每个进程。在内核中，访问任务通常需要获得指向其taks_struct的指针。实际上，内核大部分处理进程的代码都是直接通过task_struct进行的。

###### 进程状态

&emsp;&emsp;进程描述符中state域描述了进程的当前状态。系统中的每个进程都必然处于五种进程状态中的一种。

&emsp;&emsp;1.TASK_RUNNING(运行)---进程时可执行的：它或者正在执行，或者在运行队列中等待执行。这时进程在用户控件中执行的唯一可能的状态。这种状态也可以应用到内核控件中正在执行的进程。

&emsp;&emsp;2.TASK_INTERRUPTIBLE(可中断)---进程正在睡眠(也就是说它被阻塞)，等待某些条件的达成。一旦这些条件达成，内核就会把进程状态设置为运行。处于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行。

&emsp;&emsp;3.TASK_UNINTERRUPTIBLE(不可中断)---除了就算是接收到信号也不会被唤醒或准备投入运行外，这个状态与可打断状态相同。这个状态通常在进程必须在等待时不受干扰或等待事件很快就会发生时出现。由于处于此状态的任务对信号不做响应，所以较之可中断状态，使用得较少。

&emsp;&emsp;4._TASK_TRACED---被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪。

&emsp;&emsp;5._TASK_STOPPED（停止）---进程停止执行，进程没有投入运行也不能投入运行。通常这种状态发生在接收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTO等信号的时候。此外，在调试期间接收到任何信号，都会使进程进入这种状态。


<div align="center">
	<img src="/images/posts/linux/linux-p-2.png" height="467" width="742">
</div>

###### 设置当前进程状态

&emsp;&emsp;内核经常需要调整某个进程的状态。这时最好使用set_task_state(task, state)函数：
```java
    set_stask_state(task, state); //将任务task的状态设置为state
```

该函数将指定的进程设置为指定的状态。


###### 进程上下文

&emsp;&emsp;可执行程序代码时进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行。当一个程序调执行了系统调用或者出发了某个异常，它就陷入了内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。在此上下文中current宏时有效的。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整。否则，在内核退出的时候，程序恢复在用户空间会继续执行。

###### 进程家族树

&emsp;&emsp;进程之间存在继承关系。所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本并执行其他的相关程序，最终完成系统启动的整个过程。

&emsp;&emsp;系统中每个进程必有一个父进程，相应的，每个进程也可以拥有零个或多个子进程。拥有同一个父进程的所有进程被称为<b>兄弟</b>。进程间的关系存放在进程描述符中。每个task_struct都包含一个指向其父进程tast_struct、叫做parent的指针，还包含一个称为children的子进程链表。所以，对于当前进程，可以通过下面代码获得其父进程的进程描述符
```java
sturct task_struct *my_parent = current -> parent;
```
同样可以按以下方式依次访问子进程:






