---
layout: post
title:  Linux进程管理
date:   2017-02-27 10:25:00 +0800
tag: linux内核
---

##### 进程

&emsp;&emsp;&emsp;进程就是处于执行期的程序（目标码存放在某种存储介质上）。但进程并不仅仅局限于一段可执行程序代码。通常进程还要包括其他资源，像打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址控件及一个或多个执行线程(thread of execution)，当然还包括用来存放全局变量的数据段等。实际上，进程就是正在执行的程序代码的实时结果。内核需要有效而又透明地管理所有细节。

&emsp;&emsp;执行线程，简称线程，是在进程中活动的对象。每个线程都拥有一个盾立的程序计数器、进程栈、和一组进程寄存器。内核调度的对象时线程，而不是进程。在传统的Unix系统中，一个进程只包含一个线程，但现在的系统中，包含多个线程的多线程程序司空见惯。Linux系统的线程实现非常特别：它对线程和进程并不特别区分。对Linux而言，线程只不过时一种特殊的进程罢了。

&emsp;&emsp;进程提供两种虚拟机制：虚拟处理器和虚拟内存。

&emsp;&emsp;程序本身并不是进程，进程是处于执行期的程序以及相关的资源的总称。实际上，完全可能存在两个或多个不同的进程执行的时同一个程序。并且两个或两个以上并存的进程还可以共享许多诸如打开的文件、地址空间之类的资源。

&emsp;&emsp;Linux中，通常调用fork()系统的结果，该系统调用用通过复制一个现有进程来创建一个全新的进程。调用fork()的进程称为父进程，新产生的进程称为子进程。在该调用结束时，在返回点这个相同的位置上，父进程恢复执行，子进程开始执行。fork()系统调用从内核返回两次：一次回到父进程，另一次回到新产生的子进程。

&emsp;&emsp;通常，创建新的进程都是为了立即执行新的或不同的程序，而接着调用exec()这组函数就可以创建新的地址空间，并把新的程序载入其中。在现在Linux内核中，fork()实际上是由clone()系统实现的。

&emsp;&emsp;最终，程序通过exit()系统调用退出执行。这个函数会终结进程并将其占用的资源释放掉。父进程可以通过wait4()系统调用查询子进程是否中介，这其实使得进程呢拥有了等待特定进程执行完毕的能力。进程退出执行后被设置为僵死状态，
知道它的父进程调用wait()或waitpid()为止。

##### 进程描述符及任务结构

&emsp;&emsp;内核把进程的列表存放在任务队列中，它是双向循环链表。链表中的每一项都是类型为task_struck、称为进程描述符的结构。包含一个具体进程的所有信息。

&emsp;&emsp;例如：它打开的文件。进程的地址控件，挂起的信号。进程的状态，还有其他更多信息。








